#include <stdio.h>
#include <signal.h>
#include <setjmp.h>
#include <sys\stat.h>
#include <unistd.h>

sigjmp_buf obl; /* область памяти для запоминания
 состояния процесса */
main(){
    void prer(); /* подпрограмма обработки прерывания */
    int end_flag; /* флаг завершения работы программы*/
    int descr[2]; /* дескрипторы межпроцессного канала */
    signal(SIGINT, prer); /* уведомление о том, что 
    в случае при¬хода сигнала прерывания SIGINT, 
    управление передается процедуре prer */
    sigsetjmp(obl, 1); /* запоминание текущего 
    состояния процесса */
    end_flag = 0;
    do{
        sigsetjmp(obl, 1);
        pipe(descr); /* создание межпроцессного канала */
        if(fork() == 0) /* распараллеливание процесса */
        {               /* процесс-потомок */
            close(1);      /* закрытие стандартного вывода */    
            close(descr[0]);   /* закрытие межпроцессного канала 
            на чтение */ 
            dup2(g[l],1);  /* дублирование дескриптора 
            межпроцессного канала на стандартный вывод */ 
            close(g[1]);   /* удалить копию */
            execl("/bin/ps",  "ps",  "ax", 0); /* вывод всех 
            активных процессов в системе в межпроцессный канал */


        }
        else 
       {	      /* процесс-родитель */
            wait(&s);      /* ожидание окончания процесса-потомка */ 
            sigsetjmp(obl,1);
            close(g[1]);
            read(g[0], n, 80); /* считывание 1-ой записи из меж-процессного канала */
            read(g[0], nl, 80); /* считывание 2-й записи */
            rr = cmpstr(n, nl); /* сравнение двух строк */
            sigsetjmp(obl,1);	
            while (rr != -1)	
            {
                if(n1[7] == 'j') break; /* процесс управляется 
                пользовательским терминалом */ 
                m = atoi(nl); /* определение первого целого
                        числа из строки nl */
                if(m == 0) vv = 1;
                if((gg == 0) && (m != 0)) printf ("%d\n", gg); 
                if (gg != m) printf ("%d\n", m); 
                gg = m;
                read (g[0], n, 80);
                rr = cmpstr(n, nl); 
                strcpy(nl, n); 
                sleep( 1);    /* ожидание 1 сек.  */
		    }
       }
        while (vv != 1);	
        sigsetjmp(obl,1);	
        printf("good bye !!!\n");
    }
}
/* Подпрограмма обработки прерывания */
void po13() 
{
    ll ++;
    signal (SIGINT, pol3);
    if (11 > 9)	/* не больше 9ти прерываний */
    {
        printf ("good bye\n");
        exit(l);
    }
    printf(" П P E P Ы В А Н И E   !!!  \n"); 
    siglongjmp (obl, 1);    /* возвращение на последний     setjmp */
}
/* Подпрограмма сравнения строк */ 
int cmpstr(vv,  nn)
{
    char vv[ ],  nn[ ];
    int  i,  ml,  m2;
    for (m1 = 0; vv[m1] != '\0'; ml ++); 
    for (m2 = 0; vv[m2] != '\0'; m2 ++);
    if (m1 != m2) return (0); /* длины строк vv и nn разные */ 
    for (i = 0; i < ml; i ++)
    {
        if (vv[i] != nn[i]) return (i + 1); /* строки равны по
        длине, но отличаются (i + 1) символом */
        return(-1); /* строки одинаковы */
    }
}


